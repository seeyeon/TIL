# 🌳 B-tree 인덱스
## 📌 인덱스란?

칼럼 값 + 해당 레코드 주소 = **(Key, Value)** 구조로 만들어진 검색 도우미 자료구조

| 구조                     | 비유         | 설명               |
| ---------------------- | ---------- | ---------------- |
| **인덱스 (B-tree)**       | 책의 목차 / 색인 | 빠르게 원하는 데이터를 찾는다 |
| **데이터 파일 (ArrayList)** | 책의 본문      | 삽입은 쉽지만 검색은 느리다  |

| 항목       | SortedList (인덱스 구조) | ArrayList (데이터 파일 구조) |
| -------- | ------------------- | --------------------- |
| 저장 방식    | 정렬된 상태로 저장          | 입력 순서대로 저장            |
| 삽입/삭제 속도 | 느림 (정렬 유지)          | 빠름                    |
| 검색 속도    | 빠름 (O(log n))       | 느림 (O(n))             |

> ✅ 인덱스는 저장 속도를 일부 희생하고 **검색 속도**를 비약적으로 향상시키는 장치

---

## 🌲 B-tree 인덱스란? (Balanced Tree)

* **Binary가 아니라 Balanced Tree의 약자**
* **대부분의 인덱스는 B-tree 기반**
* 루트 → 브랜치 → 리프 구조
* **리프 노드는 실제 데이터 주소 포함**

```
        [50]              ← 루트 노드
       /    \ 
   [30]     [70]          ← 브랜치 노드
  /   \     /   \
[10] [40] [60] [80]       ← 리프 노드
```

* 인덱스는 정렬돼 있으나 **데이터 레코드는 정렬되어 있지 않음**
* InnoDB에서는 **프라이머리 키 기준 정렬 저장**

---

## 🧱 인덱스 키 삽입 (Insert)

* 키 값으로 적절한 리프 위치 탐색 → 삽입
* 노드가 다 찼다면 **Split 발생**
* 인덱스 삽입 비용은 대략 **레코드 추가의 1.5배**

|        | MyISAM / MEMORY | InnoDB            |
| ------ | --------------- | ----------------- |
| 인덱스 삽입 | 즉시 반영           | 지연 처리 가능 (체인지 버퍼) |

---

## 🧹 인덱스 키 삭제 (Delete)

* 리프 노드에서 **삭제 마크**만 처리
* 공간은 재활용 가능

|        | MyISAM / MEMORY | InnoDB       |
| ------ | --------------- | ------------ |
| 인덱스 삭제 | 즉시 처리           | 버퍼링되어 나중에 처리 |

---

## 🔁 인덱스 키 수정 (Update)

* **인덱스 값 변경은 불가능**
* 실제 동작: **Delete → Insert**
* InnoDB는 **체인지 버퍼**로 지연 반영

> 🔎 **체인지 버퍼란?**
> 디스크 I/O를 줄이기 위해 **삽입·삭제·수정 작업을 버퍼에 저장**하고, 나중에 디스크 반영하는 InnoDB 전용 기능

---

## 🧭 인덱스 검색 방식

* 루트 → 브랜치 → 리프 순서로 탐색
* `SELECT`, `UPDATE`, `DELETE` 모두 인덱스 탐색 포함
* 아래 조건일 때는 인덱스 사용 **불가**:

  * `column + 1`, `UPPER(column)` 같은 함수/연산 사용
  * LIKE 앞에 `%` 붙은 경우
  * `!=`, `NOT IN`, `IS NOT NULL` 등

---

## 🧾 삽입/삭제/수정 요약

| 연산         | 방식         | 특징                |
| ---------- | ---------- | ----------------- |
| **INSERT** | 위치 탐색 후 삽입 | 리프가 꽉 차면 Split 발생 |
| **DELETE** | 삭제 마킹      | 공간 재사용 가능         |
| **UPDATE** | 삭제 + 삽입    | 실질적 재삽입           |

---

## ⚔️ InnoDB vs MyISAM

```sql
CREATE TABLE members (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE=InnoDB; -- 또는 ENGINE=MyISAM
```

| 항목     | InnoDB                  | MyISAM              |
| ------ | ----------------------- | ------------------- |
| 트랜잭션   | ✅ 지원                    | ❌ 미지원               |
| 외래키    | ✅ 지원                    | ❌ 미지원               |
| 인덱스 구조 | 클러스터 인덱스 (PK 기준)        | 보조 인덱스 (주소 참조)      |
| 정렬 방식  | 프라이머리 키 순               | 정렬 없음               |
| 변경 처리  | 체인지 버퍼 활용               | 즉시 처리               |
| 사용 환경  | 트랜잭션 중심, 다중 사용자, 무결성 우선 | 빠른 조회, 단순 서버, 블로그 등 |
| 예시     | 금융, 쇼핑몰                 | 뉴스, 검색 기록           |

> 📌 **MyISAM이 아직도 쓰이는 이유**
>
> * 빠른 읽기 성능
> * 디스크 공간 절약
> * 레거시 호환성
> * 파일 복사로 백업 가능 (`.frm`, `.MYD`, `.MYI`)

---

## 🚀 B-tree 인덱스 성능 요소

1. **칼럼 크기**: 크면 디스크 I/O 증가 → 느림
2. **키 값 크기**: 클수록 한 페이지에 저장 가능한 수 ↓ → 트리 깊이 ↑
3. **선택도(기수성)**: 높을수록 성능 ↑
4. **읽는 레코드 수**: 전체의 20\~25% 이상이면 인덱스 **미사용**

---

## 🧠 인덱스 탐색 방식

### ✅ 인덱스 레인지 스캔

```sql
SELECT * FROM employee WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

* 범위가 명확할 때 사용

---

### ✅ 인덱스 풀 스캔

```sql
SELECT id FROM employee;
```

* 처음부터 끝까지 인덱스 전체 탐색

---

### ✅ 루스 인덱스 스캔

```sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

* 필요 없는 인덱스는 건너뜀

---

### ✅ 인덱스 스킵 스캔 (MySQL 8.0\~)

```sql
ALTER TABLE employee ADD INDEX ix_gender_birthdate (gender, birth_date);

-- 조건 없이도 사용 가능
SELECT * FROM employee WHERE birth_date >= '1999-10-01';
```

* **선두 컬럼 없이도** 인덱스 탐색 가능
* `SET optimizer_switch='skip_scan=on';`
* **복합 인덱스에서만 의미 있음**

---

## 🎯 인덱스 가용성과 효율성

### 📌 인덱스 순서의 효율성

```sql
-- 인덱스: (dept_no, emp_no)
SELECT * FROM employee WHERE dept_no = 'd002' AND emp_no >= 10114;
```

* dept\_no로 범위를 좁히고 emp\_no로 세부 탐색 → **효율적**

```sql
-- 인덱스: (emp_no, dept_no)
SELECT * FROM employee WHERE dept_no = 'd002' AND emp_no >= 10114;
```

* emp\_no 조건만 탐색, dept\_no는 **필터링 역할만** → **비효율적**

> ✅ 일반적으로는 `=` 같은 **동등 조건이 앞**, `>`, `<` 같은 비교 조건이 뒤에 와야 효율적

---

### 📌 인덱스 사용 어려운 조건들

| 조건 유형          | 이유            | 예시                                      | 인덱스 사용 여부 |
| -------------- | ------------- | --------------------------------------- | --------- |
| `!=`, `<>`     | 정렬 불가         | `WHERE dept_no != 'd002'`               | ❌         |
| `NOT IN (...)` | 제외 조건은 예측 불가  | `WHERE dept_no NOT IN ('d001', 'd002')` | ❌ 또는 ✅    |
| `LIKE '%abc'`  | 앞 `%` → 정렬 무효 | `WHERE first_name LIKE '%son'`          | ❌         |
| `IS NOT NULL`  | 전체 탐색 필요      | `WHERE birth_date IS NOT NULL`          | ❌ 또는 ✅    |
| 함수 사용          | 값 변형 → 정렬 무의미 | `WHERE UPPER(name) = 'ALICE'`           | ❌         |
