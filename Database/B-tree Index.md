## 📌 인덱스란?

칼럼 값 + 해당 레코드 주소 = **(Key, Value)** 구조로 만들어진 검색 도우미 자료구조

| 구조                     | 비유         | 설명               |
| ---------------------- | ---------- | ---------------- |
| **인덱스 (B-tree)**       | 책의 목차 / 색인 | 빠르게 원하는 데이터를 찾는다 |
| **데이터 파일 (ArrayList)** | 책의 본문      | 삽입은 쉽지만 검색은 느리다  |

DBMS에서 인덱스는 칼럼 값을 주어진 순서로 미리 정렬해서 보관하는데, 이러한 특성 때문에 정렬된 리스트(SortedList)는 DBMS의 인덱스와 같은 자료구조로, 저장된 순서대로 값을 저장하는 ArrayList는 일반적인 데이터 파일과 같은 구조로 볼 수 있다.


| 항목       | SortedList (인덱스 구조) | ArrayList (데이터 파일 구조) |
| -------- | ------------------- | --------------------- |
| 저장 방식    | 정렬된 상태로 저장          | 입력 순서대로 저장            |
| 삽입/삭제 속도 | 느림 (정렬 유지)          | 빠름                    |
| 검색 속도    | 빠름 (O(log n))       | 느림 (O(n))             |

SortedList는 저장하는 과정이 복잡하고 느리지만, 정렬된 상태로 인해 검색이 매우 빠르다는 장점이 있다. 반면, ArrayList는 삽입이 빠르지만 검색에는 전체 순회를 필요로 하므로 느릴 수 있다. 이와 마찬가지로 인덱스는 INSERT, UPDATE, DELETE 시에는 느리지만 SELECT 시에는 매우 빠르게 처리될 수 있다. 

따라서 인덱스를 사용할지 여부는 데이터의 저장 속도를 어디까지 희생할 수 있는지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지에 따라 결정해야 한다. 인덱스는 데이터를 관리하는 방식(알고리즘)과 중복 값의 허용 여부 등에 따라 다양한 종류로 나뉘는데, 그중 대표적인 것이 B-tree 인덱스이다.

---

## 🌲 B-tree 인덱스란? (Balanced Tree)

B-tree 인덱스는 데이터베이스 인덱싱 알고리즘 중 **가장 일반적으로 사용되고, 가장 먼저 도입된 구조로, 지금까지도 범용적으로 널리 사용**된다. 단, 여기서 B는 Binary가 아니라 Balanced를 의미한다.

전문 검색과 같은 특수한 경우를 제외하면 **대부분의 인덱스는 B-tree 기반**으로 동작하며, 구조는 루트 노드, 브랜치 노드, 리프 노드로 구성된 트리 형태를 가진다. 인덱스와 실제 데이터는 별도로 관리되며, 리프 노드는 실제 데이터 레코드를 찾아가기 위한 주솟값을 가진다.

⏩ B가 Binary 가 아니라 Balanced인 이유?
: 자식이 2개가 아니라 다수(M개)일 수 있고, 디스크 접근 최적화를 위해 설계되었다. 또한 트리가 항상 균형을 유지해 탐색 효율을 보장한다. 

```
        [50]              ← 루트 노드
       /    \ 
   [30]     [70]          ← 브랜치 노드
  /   \     /   \
[10] [40] [60] [80]       ← 리프 노드
```

+ **리프 노드**는 실제 데이터의 위치 정보를 포함
* **트리 탐색** : 루트 → 브랜치 → 리프 순서로 검색

인덱스의 키 값은 정렬돼 있지만 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장되어 있다. 따라서 레코드가 삭제되어 빈 공간이 생기면, 그 다음의 INSERT는 가능한 삭제된 공간을 재활용하도록 DBMS가 설계되어 있기 때문에, 항상 INSERT된 순으로 저장되는 것은 아니다.

다만, InnoDB 테이블에서는 레코드가 클러스터되어 디스크에 저장되므로, 기본적으로 프라이머리 키 순서로 정렬되어 저장된다.

---

## 🧱 인덱스 키 삽입 (Insert)

B-tree에 저장될 때에는 저장될 키 값을 이용해 적절한 위치를 검색한 뒤, 해당 위치에 레코드의 키 값과 주소 정보를 리프 노드에 저장한다.

만약 리프 노드가 다 찼다면 split이 발생하게 되며, 이는 상위 브랜치 노드까지 영향을 미치게 된다. 따라서 인덱스를 추가하는 작업은 단순히 값을 넣는 것만으로 끝나는 것이 아니며, 트리 전체 구조에 영향을 줄 수 있다. 이로 인해 insert나 update 문장이 영향을 받는데, 이는 테이블의 칼럼 수, 칼럼 크기, 인덱스 특성 등에 따라 달라진다.

대략적으로는 테이블에 레코드 추가 비용이 1이라면, 인덱스 키를 추가하는 작업 비용은 약 1.5배에 이를 수 있다.

|        | MyISAM / MEMORY | InnoDB            |
| ------ | --------------- | ----------------- |
| 인덱스 삽입 | 즉시 반영           | 지연 처리 가능 (체인지 버퍼) |

---

## 🧹 인덱스 키 삭제 (Delete)

삭제 작업은 비교적 단순하다. 해당 키 값이 저장된 리프 노드를 찾아가 삭제 마크만 하면 된다. 삭제 마크된 인덱스 키 공간은 그대로 방치되거나 재활용될 수 있다

|        | MyISAM / MEMORY | InnoDB       |
| ------ | --------------- | ------------ |
| 인덱스 삭제 | 즉시 처리           | 버퍼링되어 나중에 처리 |

---

## 🔁 인덱스 키 수정 (Update)

인덱스 키 값은 해당 값에 따라 저장될 리프 노드의 위치가 결정되기 때문에, 단순히 인덱스 상의 키 값만 바꾸는 것은 불가능하다. 따라서 인덱스 키 값을 수정하는 작업은 사실상 기존 값을 삭제한 뒤 새로운 값을 추가하는 두 단계로 수행된다. InnoDB는 이 작업 역시 체인지 버퍼를 통해 지연 처리할 수 있다.

🔎 **체인지 버퍼란?**
InnoDB에서만 사용되는 기능으로, 인덱스의 변경 작업을 즉시 반영하지 않고, 버퍼에 저장한 뒤 필요할 때 디스크에 반영함으로써 디스크 I/O를 최소화하는 역할을 한다. 이는 삽입, 삭제, 갱신 등의 작업에서 유용하게 작용한다.

---

## 🧭 인덱스 검색 방식

인덱스를 사용하는 검색 작업은 루트 노드부터 시작해 브랜치 노드를 거쳐 리프 노드까지 탐색하며 비교 작업을 수행하는 방식으로 이루어진다. 이 과정을 트리 탐색(tree traversal)이라고 하며, SELECT뿐 아니라 UPDATE, DELETE 시에도 사용된다.

B-tree 인덱스는 100% 일치하거나 앞부분이 일치하는 경우에 성능이 가장 뛰어나며, 부등호나 비교 조건이 있어도 일부 활용이 가능하다. 하지만 키 값의 뒷부분만 검색하거나, 키 값에 함수나 연산이 가해진 경우에는 B-tree의 빠른 탐색 기능을 사용할 수 없다. 즉, WHERE 절에 `column + 1` 또는 `UPPER(column)`과 같은 조건이 들어가면 인덱스를 사용할 수 없다.

## 🧾 삽입/삭제/수정 요약

| 연산         | 방식         | 특징                |
| ---------- | ---------- | ----------------- |
| **INSERT** | 위치 탐색 후 삽입 | 리프가 꽉 차면 Split 발생 |
| **DELETE** | 삭제 마킹      | 공간 재사용 가능         |
| **UPDATE** | 삭제 + 삽입    | 실질적 재삽입           |

---

## ⚔️ InnoDB vs MyISAM

+ InnoDB : MySQL의 기본 스트리지 엔진( 데이터베이스 시스템이 데이터를 어떻게 저장, 관리, 검색할지 결정하는 '저장 방식의 내부 로직')
+ MyISAM : MySQL 초창기 기본 스토리지 엔진

```sql
CREATE TABLE members (
  id INT PRIMARY KEY,
  name VARCHAR(50)
) ENGINE=InnoDB; -- 또는 ENGINE=MyISAM
```
- mysql 버전이 5.5 이하면 ENGINE=MyISAM(기본값) / 5.5 이상이 ENGINE=InnoDB;(기본값)
- 현재 내 기본 엔진이 뭔지 확인하는 법 → `SHOW ENGINES;`

| 항목     | InnoDB                  | MyISAM              |
| ------ | ----------------------- | ------------------- |
| 트랜잭션   | ✅ 지원                    | ❌ 미지원               |
| 외래키    | ✅ 지원                    | ❌ 미지원               |
| 인덱스 구조 | 클러스터 인덱스 (PK 기준)        | 보조 인덱스 (주소 참조)      |
| 정렬 방식  | 프라이머리 키 순               | 정렬 없음               |
| 변경 처리  | 체인지 버퍼 활용               | 즉시 처리               |
| 사용 환경  | 트랜잭션 중심, 다중 사용자, 무결성 우선 | 빠른 조회, 단순 서버, 블로그 등 |
| 예시     | 금융, 쇼핑몰                 | 뉴스, 검색 기록           |

📌 **MyISAM이 아직도 쓰이는 이유**

MyISAM은 구버전 스토리지 엔진이지만, 특정한 상황에서는 여전히 유용하기 때문에 MySQL이 지원을 유지하고 있다.

1. 읽기 성능이 뛰어남 
- **트랜잭션**, **외래 키**, **복잡한 무결성 검사**가 없기 때문에 오버헤드가 적고,
- **전체 테이블 잠금(Table Lock)** 방식으로 인해 **단순한 읽기 작업에 빠르게 응답**

2. 디스크 공간을 적게 사용함
인덱스와 데이터 구조가 간단해서 디스크 사용량이 InnoDB보다는 적음

3. 레거시 시스템과의 호환성
- 과거 MySQL 5.1 이하 버전에서 만들어진 시스템들이 아직도 존재하기 때문에 유지보수 및 호환 목적으로 필요함

4. 단순한 구조로 복사/백업이 쉬움
- .frm .MYD .MYI 파일 구조로 되어 있어 파일 복사만으로 테이블을 이동할 수 있어 단순 백업에 유리함

→ 그렇지만, 데이터 무결성이 부족하고 동시성이 낮으며 자동 복구 기능이 없어 특별한 이유가 있을 떄만 제한적으로 사용된다. 현재는 InnoDB가 훨씬 안정적이고 유연해서 거의 표준으로 자리 잡았다

---

## 🚀 B-tree 인덱스 성능 요소

1. **칼럼 크기**: 크면 디스크 I/O 증가 → 느림 
InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지( Page)  또는 
블록(Block) 이라고 한다.  인덱스도 결국 페이지 단위로 관리되며, B-tree의 자식 노드의 개수도 페이지의 크기와 키 값의 크기에 따라 결정된다.

2. **키 값 크기**: 클수록 한 페이지에 저장 가능한 수 ↓ → 트리 깊이 ↑
실제로 아무리 대용량 DB여도 B-tree의 깊이가 5단계 이상 깊어지는 경우는 흔치 않다. 

예를 들어, 한칸에 3권밖에 넣을 수 있는데 100권의 책을 넣으려면 34칸이 필요함. 
→ 깊이가 깊어짐 

3. **선택도(기수성)**: 높을수록 성능 ↑
즉, 유일한 값을 가질수록 불필요하게 읽을 컬럼이 줄어들어 결과적으로 속도가 빨라진다는 것이다. 

4. **읽는 레코드 수**: 전체의 20\~25% 이상이면 인덱스 **미사용**
이때, 인덱스를 활용한 읽기의 손익 분기점은 RDBMS 서버별로 차이가 있다. 대략, 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 든다고 예측한다. 

만약, 100만건 레코드 가운데 50만건을 읽는 작업은 인덱스의 손익 분기점 20~25%를 넘기때문에 MySQL 옵티마이저는 인덱스 이용하지 않고 직접 테이블을 처음부터 끝까지 읽어 처리한다. 

---

## 심화) B-tree 인덱스를 통해 데이터를 읽는 방식

### ✅ 인덱스 레인지 스캔 
: 검색해야할 인덱스의 범위가 결정되었을 때 사용하는 방식

```sql
SELECT * FROM employee WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

### ✅ 인덱스 풀 스캔 
: 인덱스의 처음부터 끝까지 모두 읽는 방식

```sql
SELECT id FROM employee;
```
테이블 풀 스캔보단 낫지만 인덱스를 효율적으로 사용하는 방식은 아니다. 

### ✅ 루스 인덱스 스캔 
: 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.

```sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```
- dept_emp 테이블은 dept_no와 emp_no라는 두 개의 칼럼으로 인덱스가 생성돼 있다`(가정)`
- 이떄 인덱스에서 where 조건을 만족하지 않는 ‘d003’ 레코드는 무시하고 다음 레코드로 이동한다.

### ✅ 인덱스 스킵 스캔 (MySQL 8.0\~) 
: 선두 컬럼을 건너뛰고(index skip) 그 다음 컬럼에 조건이 있을 때 인덱스를 가능한 활용하는 방법

```sql
alter table employee add index ix_gender_birthdate (gender, birth_date);

이전, select * from employee where birth_date >='1999-10-01'; 인덱스 사용X(gender 조건 없음) 
			select * from employee where gender='M' and birth_date >='1999-10-01'; 인덱스 사용O

이후, select * from employee where birth_date >='1999-10-01'; 인덱스 사용O(gender 조건 뛰어넘음)
```

* **선두 컬럼 없이도** 인덱스 탐색 가능
* 인덱스 스킵 스캔 활성화하는 방법 →  `SET optimizer_switch='skip_scan=on';`
* **복합 인덱스에서만 의미 있음**
```sql
select * from employee where birth_date>='1965-02-01';

→ 모든 칼럼을 조회해야하므로 인덱스 스킵 스캔이 사용되지 않고 풀 테이블 스캔이 발생함.
```


---

## 심화) B-tree 인덱스의 가용성과 효율성

1. 비교 조건의 종류와 효율성

```sql
-- 인덱스: (dept_no, emp_no)
SELECT * FROM employee WHERE dept_no = 'd002' AND emp_no >= 10114;
```

* dept\_no로 범위를 좁히고 emp\_no로 세부 탐색 → **효율적**

```sql
-- 인덱스: (emp_no, dept_no)
SELECT * FROM employee WHERE emp_no >= 10114 and dept_no = 'd002';
```

* emp\_no 조건만 탐색, dept\_no는 **필터링 역할만** → **비효율적**

> ✅ 일반적으로는 `=` 같은 **동등 조건이 앞**, `>`, `<` 같은 비교 조건이 뒤에 와야 효율적

2. 인덱스의 가용성
B-tree 인덱스는 왼쪽 값에 기준해서 오른쪽 값이 정렬되어 있다는 것이 특징이다. 
→ 즉, 앞 컬럼부터 정렬하고 탐색한다.
→ 즉, 방향이 아니라 우선순위의 개념으로 이해해야한다.

```sql
SELECT * FROM employee
WHERE first_name LIKE '%mer';
```
- 위 쿼리는 인덱스 레인지 방식으로 인덱스를 이용할 수 없다.
- 조건절에 주어진 상수값(’%mer)에는 왼쪽 부분이 고정되어 있지 않기때문이다.
- 위 쿼리는 **테이블 풀 스캔**이 발생한다.

3. 가용성과 효율성 판단
아래 조건에서는 작업 범위 결정 조건으로 사용할 수 없고, 경우에 따라 체크 조건으로 인덱스를 사용할 수 있다. 

### 📌 인덱스 사용 어려운 조건들

| ❗ 조건 유형          | ❌ 인덱스 사용이 어려운 이유                                              | 📌 예시 SQL 코드                                                    | 인덱스 사용 여부                      |
|----------------------|---------------------------------------------------------------------------|----------------------------------------------------------------------|--------------------------------------|
| `!=`, `<>` (부등호)  | 특정 값을 제외하는 조건은 **정렬 기반 범위 설정이 불가능**함              | `SELECT * FROM employee WHERE dept_no != 'd002';`                    | ❌ (일반적으로 테이블 풀 스캔)        |
| `NOT IN (...)`       | 마찬가지로 **제외 조건**이며, 어떤 값이 선택될지 **예측 불가**            | `SELECT * FROM employee WHERE dept_no NOT IN ('d001', 'd002');`      | ❌ 또는 ✅ (경우에 따라)<br>항목이 적고 인덱스 커버링 조건이면 가끔 index + filter, 대부분은 **풀 스캔** |
| `LIKE '%abc'`        | `%`가 앞에 오면 정렬 기준이 깨져서 **인덱스가 무의미해짐**                | `SELECT * FROM employee WHERE first_name LIKE '%son';`              | ❌ (일반적으로 테이블 풀 스캔)        |
| `IS NOT NULL`        | 모든 **NULL이 아닌 값 전체를 탐색**해야 하므로 범위 설정 불가             | `SELECT * FROM employee WHERE birth_date IS NOT NULL;`              | ❌ 또는 ✅ (경우에 따라)<br>복합 조건 또는 인덱스 커버링 시 일부 필터링 가능 |
| `함수 사용 조건`     | 인덱스는 **원래 컬럼 값 기준으로 정렬**되므로, 가공된 값은 인덱스를 쓸 수 없음 | `SELECT * FROM employee WHERE UPPER(first_name) = 'ALICE';`         | ❌ (일반적으로 테이블 풀 스캔)        |

